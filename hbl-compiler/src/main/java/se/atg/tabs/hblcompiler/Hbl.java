/* Hbl.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. Hbl.java */
  package se.atg.tabs.hblcompiler;
  import java.io.InputStream;
  import java.io.PrintStream;

  public class Hbl/*@bgen(jjtree)*/implements HblTreeConstants, HblConstants {/*@bgen(jjtree)*/
  protected static JJTHblState jjtree = new JJTHblState();private static Integer error_count = 0;
    private static Integer exit_code = 0;
    private static String input_filename = null;
    private static String output_filename = null;
    private static InputStream inputStream = null;
    private static PrintStream outputStream = null;
    private static PrintStream errorStream = System.err;
    private static Boolean inputStream_opened = false;
    private static Boolean outputStream_opened = false;
    private static IncludeManager includeManager = new IncludeManager();
    public static Hbl parser = null;

    public static void main( String[] args ) {
      parse_options(args);
      if (error_count == 0) {
        open_files();
        if (exit_code == 0) {
          includeManager.setRoot(new FileNode(input_filename));
          parse(true);
          if (exit_code == 0) {
            parse(false);
          }
        }
      } else {
        exit_code = 3;
      }
      close_files();
      System.exit(exit_code);
    }

    public static void parse(Boolean preprocessing) {
      try {
        SimpleNode node = null;
        if (parser == null) {
          parser = new Hbl( inputStream );
        } else {
          parser.ReInit(inputStream);
        }
        try {
          if (!preprocessing) {
            node = parser.Start();
          } else {
            node = parser.Preprocess();
            /*
            TODO:
            Next the following needs to get done.
            - In the first release we will only handle one level of Includes and
              will throw an error if we find more includes. We can probably just
              let the parser throw an error that the Include was unexpexted in
              this case. I.e., no special handling of the error.
            - Update the Include() rule in the grammar below so that it adds
              FileNodes for all found includes.
            - Create a temp file and write out the complete contents to this file.
            - Now invoke the parser again on the tempfile.
            - Modify ParserException so that we replace the line,column with the
              original filename, line and column by using the IncludeManager.
            - Should also refactor everything so that we don't have so much
              Java code in this jjt-file, clean up the code also.
            - Should also add to the Jira backlog that some docs for the parser
              and the Atom customizations so that it is reasonable to modify/extend
              the grammar later on.
            */
          }
        } catch (Exception e) {
          error_count += 1;
          error(e.getMessage());
        }
        if (error_count > 0) {
          exit_code = 1;
        } else if (!preprocessing && outputStream != null) {
          outputStream.println(node.generate().toString());
        }
      } catch (Exception e) {
        System.err.println(e.getMessage());
        e.printStackTrace();
        exit_code = 2;
      }
    }

    // Used for TestNG tests
    public static void parse(InputStream iStream, PrintStream oStream, PrintStream eStream) {
      inputStream = iStream;
      outputStream = oStream;
      System.setErr(eStream);
      parse(false);
    }

    public static void open_files() {
      if (input_filename != null) {
        if (input_filename.equals("-")) {
          inputStream = System.in;
        } else {
          try {
            inputStream = new java.io.FileInputStream(new java.io.File(input_filename));
            inputStream_opened = true;
          }
          catch (Exception e) {
            error("Error: Could not open input file " + input_filename);
            System.err.println(e.getMessage());
            e.printStackTrace();
            exit_code = 4;
          }
        }
      } else {
        error("Error: No input given.");
        exit_code = 4;
      }
      if (output_filename != null) {
        if (output_filename.equals("-")) {
          outputStream = System.out;
        } else {
          try {
            outputStream = new java.io.PrintStream(new java.io.File(output_filename));
            outputStream_opened = true;
          }
          catch (Exception e) {
            error("Error: Could not open output file " + output_filename);
            System.err.println(e.getMessage());
            e.printStackTrace();
            exit_code = 4;
          }
        }
      }
    }

    public static void close_files() {
      if (inputStream_opened) {
        try {
          inputStream.close();
        }
        catch (Exception e) { }
      }
      if (outputStream_opened) {
        try {
          outputStream.close();
        }
        catch (Exception e) { }
      }
    }

    public static void parse_options(String[] args) {
      int ind = 0;
      while (ind < args.length) {
        if (args[ind].equals("-i")) {
          ind += 1;
          if (ind < args.length) {
            input_filename = args[ind];
            ind += 1;
            if (!input_filename.equals("-")) {
              java.io.File f = new java.io.File(input_filename);
              if(!f.exists() || f.isDirectory()) {
                error("Error: " + input_filename + " is not a valid input file name.");
              }
            }
          } else {
            error("Error: The -i option must be followed by a valid file name.");
          }
        } else if (args[ind].equals("-o")) {
          ind += 1;
          if (ind < args.length) {
            output_filename = args[ind];
            ind += 1;
            java.io.File f = new java.io.File(output_filename);
            if(f.isDirectory()) {
              error("Error: " + output_filename + " is not a valid output file name.");
            }
          } else {
            error("Error: The -o option must be followed by a valid file name.");
          }
        } else if (args[ind].equals("-h")) {
          usage();
          ind += 1;
        } else {
          error("Error: Unknown option " + args[ind]);
          ind += 1;
        }
      }
    }

    public static void usage() {
      error("Usage: hblc -i <input_file> [-o <output_file>]");
    }

    public static void error(String message) {
      System.err.println(message);
      error_count++;
    }

  static final public SimpleNode Preprocess() throws ParseException {/*@bgen(jjtree) Preprocess */
  ASTPreprocess jjtn000 = new ASTPreprocess(JJTPREPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PERIOD:
        case DASH:
        case LEFT_PAREN:
        case RIGHT_PAREN:
        case NUMBER:
        case ACCOUNTS:
        case ACCOUNT:
        case HORSES:
        case TRACKS:
        case INCLUDE:
        case PROGRAM:
        case MEETING:
        case LEG:
        case DD_BET:
        case V75_BET:
        case DD_LEGS:
        case V75_LEGS:
        case BET:
        case DD_1:
        case DD_2:
        case V75_1:
        case V75_2:
        case V75_3:
        case V75_4:
        case V75_5:
        case V75_6:
        case V75_7:
        case X1:
        case X2:
        case X3:
        case X4:
        case X5:
        case X10:
        case X20:
        case X50:
        case X100:
        case REPEAT:
        case FORTUNA:
        case RESERVES:
        case FORTUNA_SELECT:
        case ALL_HORSES:
        case BOOST:
        case IDENTIFIER:
        case STRING_LITERAL:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case INCLUDE:{
          Include();
          break;
          }
        case PERIOD:
        case DASH:
        case LEFT_PAREN:
        case RIGHT_PAREN:
        case NUMBER:
        case ACCOUNTS:
        case ACCOUNT:
        case HORSES:
        case TRACKS:
        case PROGRAM:
        case MEETING:
        case LEG:
        case DD_BET:
        case V75_BET:
        case DD_LEGS:
        case V75_LEGS:
        case BET:
        case DD_1:
        case DD_2:
        case V75_1:
        case V75_2:
        case V75_3:
        case V75_4:
        case V75_5:
        case V75_6:
        case V75_7:
        case X1:
        case X2:
        case X3:
        case X4:
        case X5:
        case X10:
        case X20:
        case X50:
        case X100:
        case REPEAT:
        case FORTUNA:
        case RESERVES:
        case FORTUNA_SELECT:
        case ALL_HORSES:
        case BOOST:
        case IDENTIFIER:
        case STRING_LITERAL:{
          AnyNonIncludeToken();
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(0);
jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Include() throws ParseException {/*@bgen(jjtree) Include */
  ASTInclude jjtn000 = new ASTInclude(JJTINCLUDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token path;
    try {
      jj_consume_token(INCLUDE);
      path = jj_consume_token(STRING_LITERAL);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
IncludeManager.getInstance().getRoot().addIncludedFileAfterLine(path.image.substring(1, path.image.length()-1), path.endLine);
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void AnyNonIncludeToken() throws ParseException {/*@bgen(jjtree) AnyNonIncludeToken */
  ASTAnyNonIncludeToken jjtn000 = new ASTAnyNonIncludeToken(JJTANYNONINCLUDETOKEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      case DASH:{
        jj_consume_token(DASH);
        break;
        }
      case LEFT_PAREN:{
        jj_consume_token(LEFT_PAREN);
        break;
        }
      case RIGHT_PAREN:{
        jj_consume_token(RIGHT_PAREN);
        break;
        }
      case NUMBER:{
        jj_consume_token(NUMBER);
        break;
        }
      case ACCOUNTS:{
        jj_consume_token(ACCOUNTS);
        break;
        }
      case ACCOUNT:{
        jj_consume_token(ACCOUNT);
        break;
        }
      case HORSES:{
        jj_consume_token(HORSES);
        break;
        }
      case TRACKS:{
        jj_consume_token(TRACKS);
        break;
        }
      case PROGRAM:{
        jj_consume_token(PROGRAM);
        break;
        }
      case MEETING:{
        jj_consume_token(MEETING);
        break;
        }
      case LEG:{
        jj_consume_token(LEG);
        break;
        }
      case DD_BET:{
        jj_consume_token(DD_BET);
        break;
        }
      case V75_BET:{
        jj_consume_token(V75_BET);
        break;
        }
      case DD_LEGS:{
        jj_consume_token(DD_LEGS);
        break;
        }
      case V75_LEGS:{
        jj_consume_token(V75_LEGS);
        break;
        }
      case BET:{
        jj_consume_token(BET);
        break;
        }
      case DD_1:{
        jj_consume_token(DD_1);
        break;
        }
      case DD_2:{
        jj_consume_token(DD_2);
        break;
        }
      case V75_1:{
        jj_consume_token(V75_1);
        break;
        }
      case V75_2:{
        jj_consume_token(V75_2);
        break;
        }
      case V75_3:{
        jj_consume_token(V75_3);
        break;
        }
      case V75_4:{
        jj_consume_token(V75_4);
        break;
        }
      case V75_5:{
        jj_consume_token(V75_5);
        break;
        }
      case V75_6:{
        jj_consume_token(V75_6);
        break;
        }
      case V75_7:{
        jj_consume_token(V75_7);
        break;
        }
      case X1:{
        jj_consume_token(X1);
        break;
        }
      case X2:{
        jj_consume_token(X2);
        break;
        }
      case X3:{
        jj_consume_token(X3);
        break;
        }
      case X4:{
        jj_consume_token(X4);
        break;
        }
      case X5:{
        jj_consume_token(X5);
        break;
        }
      case X10:{
        jj_consume_token(X10);
        break;
        }
      case X20:{
        jj_consume_token(X20);
        break;
        }
      case X50:{
        jj_consume_token(X50);
        break;
        }
      case X100:{
        jj_consume_token(X100);
        break;
        }
      case REPEAT:{
        jj_consume_token(REPEAT);
        break;
        }
      case FORTUNA:{
        jj_consume_token(FORTUNA);
        break;
        }
      case RESERVES:{
        jj_consume_token(RESERVES);
        break;
        }
      case FORTUNA_SELECT:{
        jj_consume_token(FORTUNA_SELECT);
        break;
        }
      case ALL_HORSES:{
        jj_consume_token(ALL_HORSES);
        break;
        }
      case BOOST:{
        jj_consume_token(BOOST);
        break;
        }
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      case STRING_LITERAL:{
        jj_consume_token(STRING_LITERAL);
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public SimpleNode Start() throws ParseException {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ACCOUNTS:
        case HORSES:
        case TRACKS:{
          ;
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        try {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case ACCOUNTS:{
            Accounts();
            break;
            }
          case HORSES:{
            Horses();
            break;
            }
          case TRACKS:{
            Tracks();
            break;
            }
          default:
            jj_la1[4] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } catch (ParseException e) {
HandleParseException(PERIOD, e);
        }
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PROGRAM:{
          ;
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
        try {
          Program();
        } catch (ParseException e) {
HandleParseException(PERIOD, e);
        }
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MEETING:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          break label_4;
        }
        try {
          Meeting();
        } catch (ParseException e) {
HandleParseException(PERIOD, e);
        }
      }
      jj_consume_token(0);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static void HandleParseException(int skipTo, ParseException e) throws ParseException {/*@bgen(jjtree) HandleParseException */
ASTHandleParseException jjtn000 = new ASTHandleParseException(JJTHANDLEPARSEEXCEPTION);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
try {error_count += 1;
  error(e.getMessage());
  if (skipTo != -1) {
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != skipTo);
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
  }

  static final public ASTName Name() throws ParseException {/*@bgen(jjtree) Name */
  ASTName jjtn000 = new ASTName(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token name;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        name = jj_consume_token(IDENTIFIER);
jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
jjtn000.setName(name.image);{if ("" != null) return jjtn000;}
        break;
        }
      case STRING_LITERAL:{
        name = jj_consume_token(STRING_LITERAL);
jjtree.closeNodeScope(jjtn000, true);
                                                                                           jjtc000 = false;
jjtn000.setName(name.image.substring(1, name.image.length()-1));{if ("" != null) return jjtn000;}
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void AccountSpec() throws ParseException {/*@bgen(jjtree) AccountSpec */
  ASTAccountSpec jjtn000 = new ASTAccountSpec(JJTACCOUNTSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token amount;
  ASTName name;
    try {
      name = Name();
      amount = jj_consume_token(NUMBER);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.setName(name.getName());
    jjtn000.setAmount(Integer.parseInt(amount.image));
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Accounts() throws ParseException {/*@bgen(jjtree) Accounts */
  ASTAccounts jjtn000 = new ASTAccounts(JJTACCOUNTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ACCOUNTS);
      label_5:
      while (true) {
        AccountSpec();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:
        case STRING_LITERAL:{
          ;
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(PERIOD);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void HorseSpec() throws ParseException {/*@bgen(jjtree) HorseSpec */
  ASTHorseSpec jjtn000 = new ASTHorseSpec(JJTHORSESPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token rank;
  ASTName name;
    try {
      name = Name();
      rank = jj_consume_token(NUMBER);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.setName(name.getName());
    jjtn000.setRank(Integer.parseInt(rank.image));
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Horses() throws ParseException {/*@bgen(jjtree) Horses */
  ASTHorses jjtn000 = new ASTHorses(JJTHORSES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(HORSES);
      label_6:
      while (true) {
        HorseSpec();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:
        case STRING_LITERAL:{
          ;
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          break label_6;
        }
      }
      jj_consume_token(PERIOD);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void TrackSpec() throws ParseException {/*@bgen(jjtree) TrackSpec */
  ASTTrackSpec jjtn000 = new ASTTrackSpec(JJTTRACKSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTName name;
    try {
      name = Name();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.setName(name.getName());
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Tracks() throws ParseException {/*@bgen(jjtree) Tracks */
  ASTTracks jjtn000 = new ASTTracks(JJTTRACKS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TRACKS);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:
        case STRING_LITERAL:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_7;
        }
        TrackSpec();
      }
      jj_consume_token(PERIOD);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ASTDate Date() throws ParseException {/*@bgen(jjtree) Date */
  ASTDate jjtn000 = new ASTDate(JJTDATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token year;
  Token month;
  Token day;
    try {
      year = jj_consume_token(NUMBER);
      jj_consume_token(DASH);
      month = jj_consume_token(NUMBER);
      jj_consume_token(DASH);
      day = jj_consume_token(NUMBER);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.setDate(Integer.parseInt(year.image), Integer.parseInt(month.image), Integer.parseInt(day.image));
    {if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void DDSpec(ASTLegSpecs legSpecs) throws ParseException {/*@bgen(jjtree) DDSpec */
  ASTDDSpec jjtn000 = new ASTDDSpec(JJTDDSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTLegList legList;
    try {
      try {
        jj_consume_token(DD_LEGS);
        legList = LegList();
legList.validate(2, legSpecs);
        jj_consume_token(PERIOD);
      } catch (ParseException e) {
HandleParseException(PERIOD, e);
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ASTLegList LegList() throws ParseException {/*@bgen(jjtree) LegList */
  ASTLegList jjtn000 = new ASTLegList(JJTLEGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token leg;
    try {
      label_8:
      while (true) {
        leg = jj_consume_token(NUMBER);
jjtn000.addLeg(Integer.parseInt(leg.image));
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          break label_8;
        }
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void V75Spec(ASTLegSpecs legSpecs) throws ParseException {/*@bgen(jjtree) V75Spec */
  ASTV75Spec jjtn000 = new ASTV75Spec(JJTV75SPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTLegList legList;
    try {
      try {
        jj_consume_token(V75_LEGS);
        legList = LegList();
legList.validate(7, legSpecs);
        jj_consume_token(PERIOD);
      } catch (ParseException e) {
HandleParseException(PERIOD, e);
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void PoolSpecs(ASTLegSpecs legSpecs) throws ParseException {/*@bgen(jjtree) PoolSpecs */
  ASTPoolSpecs jjtn000 = new ASTPoolSpecs(JJTPOOLSPECS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DD_LEGS:
        case V75_LEGS:{
          ;
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DD_LEGS:{
          DDSpec(legSpecs);
          break;
          }
        case V75_LEGS:{
          V75Spec(legSpecs);
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void StartList() throws ParseException {/*@bgen(jjtree) StartList */
  ASTStartList jjtn000 = new ASTStartList(JJTSTARTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTName name;
    try {
      label_10:
      while (true) {
        name = Name();
jjtn000.addHorse(name.getName());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:
        case STRING_LITERAL:{
          ;
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          break label_10;
        }
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void LegSpec() throws ParseException {/*@bgen(jjtree) LegSpec */
  ASTLegSpec jjtn000 = new ASTLegSpec(JJTLEGSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token leg;
    try {
      try {
        jj_consume_token(LEG);
        leg = jj_consume_token(NUMBER);
        StartList();
        jj_consume_token(PERIOD);
jjtn000.setLeg(Integer.parseInt(leg.image));
      } catch (ParseException e) {
HandleParseException(PERIOD, e);
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ASTLegSpecs LegSpecs() throws ParseException {/*@bgen(jjtree) LegSpecs */
  ASTLegSpecs jjtn000 = new ASTLegSpecs(JJTLEGSPECS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_11:
      while (true) {
        LegSpec();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEG:{
          ;
          break;
          }
        default:
          jj_la1[15] = jj_gen;
          break label_11;
        }
      }
jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Program() throws ParseException {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTName track;
  ASTDate date;
  ASTLegSpecs legSpecs;
    try {
      jj_consume_token(PROGRAM);
      track = Name();
jjtn000.setTrack(track.getName());
      date = Date();
jjtn000.setDate(date.toString());
      legSpecs = LegSpecs();
legSpecs.validate();
      PoolSpecs(legSpecs);
      jj_consume_token(PERIOD);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void Meeting() throws ParseException {/*@bgen(jjtree) Meeting */
  ASTMeeting jjtn000 = new ASTMeeting(JJTMEETING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTName track;
  ASTDate date;
  ASTProgram program;
    try {
      jj_consume_token(MEETING);
      track = Name();
jjtn000.setTrack(track.getName());
      date = Date();
jjtn000.setDate(date.toString());
program=ASTProgram.getProgram(track.getName(), date.toString());
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEG:
        case DD_BET:
        case V75_BET:{
          ;
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          break label_12;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DD_BET:
        case V75_BET:{
          Bet(program);
          break;
          }
        case LEG:{
          LegResult(program);
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(PERIOD);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void LegResult(ASTProgram program) throws ParseException {/*@bgen(jjtree) LegResult */
  ASTLegResult jjtn000 = new ASTLegResult(JJTLEGRESULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token leg;
    try {
      try {
        jj_consume_token(LEG);
        leg = jj_consume_token(NUMBER);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEFT_PAREN:
        case NUMBER:{
          ResultList();
          break;
          }
        default:
          jj_la1[18] = jj_gen;
          ;
        }
        jj_consume_token(PERIOD);
jjtn000.setLeg(Integer.parseInt(leg.image));
      } catch (ParseException e) {
HandleParseException(PERIOD, e);
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.validate(program);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void ResultList() throws ParseException {/*@bgen(jjtree) ResultList */
  ASTResultList jjtn000 = new ASTResultList(JJTRESULTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTResultEntry entry;
    try {
      entry = ResultEntry();
jjtn000.addEntry(entry.getHorses());
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEFT_PAREN:
        case NUMBER:{
          ;
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          break label_13;
        }
        entry = ResultEntry();
jjtn000.addEntry(entry.getHorses());
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ASTResultEntry ResultEntry() throws ParseException {/*@bgen(jjtree) ResultEntry */
  ASTResultEntry jjtn000 = new ASTResultEntry(JJTRESULTENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token number;
  ASTTie tie;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUMBER:{
        number = jj_consume_token(NUMBER);
jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
jjtn000.setEntry(Integer.parseInt(number.image)); {if ("" != null) return jjtn000;}
        break;
        }
      case LEFT_PAREN:{
        tie = Tie();
jjtree.closeNodeScope(jjtn000, true);
                                                                                                      jjtc000 = false;
jjtn000.setEntry(tie.getHorses()); {if ("" != null) return jjtn000;}
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTTie Tie() throws ParseException {/*@bgen(jjtree) Tie */
  ASTTie jjtn000 = new ASTTie(JJTTIE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token horse;
    try {
      jj_consume_token(LEFT_PAREN);
      horse = jj_consume_token(NUMBER);
jjtn000.addHorse(Integer.parseInt(horse.image));
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:{
          ;
          break;
          }
        default:
          jj_la1[21] = jj_gen;
          break label_14;
        }
        horse = jj_consume_token(NUMBER);
jjtn000.addHorse(Integer.parseInt(horse.image));
      }
      jj_consume_token(RIGHT_PAREN);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Bet(ASTProgram program) throws ParseException {/*@bgen(jjtree) Bet */
  ASTBet jjtn000 = new ASTBet(JJTBET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DD_BET:{
        DDBet(program);
        break;
        }
      case V75_BET:{
        V75Bet(program);
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void DDBet(ASTProgram program) throws ParseException {/*@bgen(jjtree) DDBet */
  ASTDDBet jjtn000 = new ASTDDBet(JJTDDBET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token amount;
  Token repeatCount;
  ASTName betID;
  ASTName accountID;
  ASTHorseSelection selection;
    try {
      jj_consume_token(DD_BET);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case REPEAT:{
        jj_consume_token(REPEAT);
        repeatCount = jj_consume_token(NUMBER);
jjtn000.setRepeatCount(Integer.parseInt(repeatCount.image));
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case STRING_LITERAL:{
        betID = Name();
jjtn000.setBetID(betID.getName());
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FORTUNA:{
        jj_consume_token(FORTUNA);
jjtn000.setFortuna(true);
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      amount = jj_consume_token(NUMBER);
jjtn000.setAmount(Integer.parseInt(amount.image));
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ACCOUNT:{
        jj_consume_token(ACCOUNT);
        accountID = Name();
jjtn000.setAccountID(accountID.getName());
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DD_1:{
        jj_consume_token(DD_1);
        selection = HorseSelection();
selection.setLeg(1);
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DD_2:{
        jj_consume_token(DD_2);
        selection = HorseSelection();
selection.setLeg(2);
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      jj_consume_token(PERIOD);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.validate(program);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ASTHorseSelection HorseSelection() throws ParseException {/*@bgen(jjtree) HorseSelection */
  ASTHorseSelection jjtn000 = new ASTHorseSelection(JJTHORSESELECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token horse;
  Token reserve;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ALL_HORSES:{
          jj_consume_token(ALL_HORSES);
jjtn000.setAllHorses(true);
          jj_consume_token(PERIOD);
          break;
          }
        case PERIOD:
        case NUMBER:
        case RESERVES:
        case FORTUNA_SELECT:{
          label_15:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case NUMBER:{
              ;
              break;
              }
            default:
              jj_la1[29] = jj_gen;
              break label_15;
            }
            horse = jj_consume_token(NUMBER);
jjtn000.addHorse(Integer.parseInt(horse.image));
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case RESERVES:
          case FORTUNA_SELECT:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case RESERVES:{
              jj_consume_token(RESERVES);
              label_16:
              while (true) {
                reserve = jj_consume_token(NUMBER);
jjtn000.addReserve(Integer.parseInt(reserve.image));
                switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                case NUMBER:{
                  ;
                  break;
                  }
                default:
                  jj_la1[30] = jj_gen;
                  break label_16;
                }
              }
              break;
              }
            case FORTUNA_SELECT:{
              jj_consume_token(FORTUNA_SELECT);
jjtn000.setFortunaSelect(true);
              break;
              }
            default:
              jj_la1[31] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[32] = jj_gen;
            ;
          }
          jj_consume_token(PERIOD);
          break;
          }
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
HandleParseException(PERIOD, e);
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void V75Bet(ASTProgram program) throws ParseException {/*@bgen(jjtree) V75Bet */
  ASTV75Bet jjtn000 = new ASTV75Bet(JJTV75BET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token amount;
  Token repeatCount;
  ASTName betID;
  ASTName accountID;
  ASTMultiplier mult;
  ASTHorseSelection selection;
    try {
      jj_consume_token(V75_BET);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case REPEAT:{
        jj_consume_token(REPEAT);
        repeatCount = jj_consume_token(NUMBER);
jjtn000.setRepeatCount(Integer.parseInt(repeatCount.image));
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:
      case STRING_LITERAL:{
        betID = Name();
jjtn000.setBetID(betID.getName());
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case X1:
      case X2:
      case X3:
      case X4:
      case X5:
      case X10:
      case X20:
      case X50:
      case X100:
      case FORTUNA:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case X1:
        case X2:
        case X3:
        case X4:
        case X5:
        case X10:
        case X20:
        case X50:
        case X100:{
          mult = Multiplier();
jjtn000.setMultiplier(mult.getValue());
          break;
          }
        case FORTUNA:{
          jj_consume_token(FORTUNA);
jjtn000.setFortuna(true);
          amount = jj_consume_token(NUMBER);
jjtn000.setAmount(Integer.parseInt(amount.image));
          break;
          }
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOST:{
        jj_consume_token(BOOST);
jjtn000.setBoost(true);
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ACCOUNT:{
        jj_consume_token(ACCOUNT);
        accountID = Name();
jjtn000.setAccountID(accountID.getName());
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_1:{
        jj_consume_token(V75_1);
        selection = HorseSelection();
selection.setLeg(1);
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_2:{
        jj_consume_token(V75_2);
        selection = HorseSelection();
selection.setLeg(2);
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_3:{
        jj_consume_token(V75_3);
        selection = HorseSelection();
selection.setLeg(3);
        break;
        }
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_4:{
        jj_consume_token(V75_4);
        selection = HorseSelection();
selection.setLeg(4);
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_5:{
        jj_consume_token(V75_5);
        selection = HorseSelection();
selection.setLeg(5);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_6:{
        jj_consume_token(V75_6);
        selection = HorseSelection();
selection.setLeg(6);
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V75_7:{
        jj_consume_token(V75_7);
        selection = HorseSelection();
selection.setLeg(7);
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        ;
      }
      jj_consume_token(PERIOD);
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
jjtn000.validate(program);
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public ASTMultiplier Multiplier() throws ParseException {/*@bgen(jjtree) Multiplier */
  ASTMultiplier jjtn000 = new ASTMultiplier(JJTMULTIPLIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case X1:{
        jj_consume_token(X1);
jjtn000.setValue(1);
        break;
        }
      case X2:{
        jj_consume_token(X2);
jjtn000.setValue(2);
        break;
        }
      case X3:{
        jj_consume_token(X3);
jjtn000.setValue(3);
        break;
        }
      case X4:{
        jj_consume_token(X4);
jjtn000.setValue(4);
        break;
        }
      case X5:{
        jj_consume_token(X5);
jjtn000.setValue(5);
        break;
        }
      case X10:{
        jj_consume_token(X10);
jjtn000.setValue(10);
        break;
        }
      case X20:{
        jj_consume_token(X20);
jjtn000.setValue(20);
        break;
        }
      case X50:{
        jj_consume_token(X50);
jjtn000.setValue(50);
        break;
        }
      case X100:{
        jj_consume_token(X100);
jjtn000.setValue(100);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public HblTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[48];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffff800,0xfffff800,0xffeff800,0xd0000,0xd0000,0x200000,0x400000,0x0,0x0,0x0,0x0,0x8000,0xc000000,0xc000000,0x0,0x800000,0x3800000,0x3800000,0xa000,0xa000,0xa000,0x8000,0x3000000,0x0,0x0,0x0,0x20000,0x20000000,0x40000000,0x8000,0x8000,0x0,0x0,0x8800,0x0,0x0,0x0,0x0,0x0,0x20000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x7fffff,0x7fffff,0x7fffff,0x0,0x0,0x0,0x0,0x600000,0x600000,0x600000,0x600000,0x0,0x0,0x0,0x600000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x600000,0x10000,0x0,0x0,0x0,0x0,0x0,0x60000,0x60000,0xe0000,0x8000,0x600000,0x17fc0,0x17fc0,0x100000,0x0,0x0,0x1,0x2,0x4,0x8,0x10,0x20,0x7fc0,};
   }

  /** Constructor with InputStream. */
  public Hbl(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Hbl(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new HblTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Hbl(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new HblTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
   } else {
      jj_input_stream.ReInit(stream, 1, 1);
   }
   if (token_source == null) {
      token_source = new HblTokenManager(jj_input_stream);
   }

    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Hbl(HblTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(HblTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[56];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 48; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 56; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  }
