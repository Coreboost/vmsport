import df_classes

stack = []

def push(item):
  if len(stack) > 0:
    stack[-1].add_child(item)
  stack.append(item)

def pop():
  popped = stack.pop()
  if len(stack) == 0:
    popped.generate()



# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class IFDLScanner(runtime.Scanner):
    patterns = [
        ('","', re.compile(',')),
        ('"\\)"', re.compile('\\)')),
        ('"\\("', re.compile('\\(')),
        ('[ \r\t\n]+', re.compile('[ \r\t\n]+')),
        ('FORM', re.compile('(?i)FORM')),
        ('END_FORM', re.compile('(?i)END[ \t]+FORM')),
        ('NAME', re.compile('\\w+')),
        ('FORM_DATA', re.compile('(?i)FORM[ \t]+DATA')),
        ('END_DATA', re.compile('(?i)END[ \t]+DATA')),
        ('FORM_RECORD', re.compile('(?i)FORM[ \t]+RECORD')),
        ('END_RECORD', re.compile('(?i)END[ \t]+RECORD')),
        ('LAYOUT', re.compile('(?i)LAYOUT')),
        ('END_LAYOUT', re.compile('(?i)END[ \t]+LAYOUT')),
        ('TRACKED', re.compile('(?i)TRACKED')),
        ('UNTRACKED', re.compile('(?i)UNTRACKED')),
        ('VALUE', re.compile('(?i)VALUE')),
        ('BYTE_INTEGER', re.compile('(?i)BYTE[ \t]+INTEGER')),
        ('DFLOATING', re.compile('(?i)DFLOATING')),
        ('FFLOATING', re.compile('(?i)FFLOATING')),
        ('GFLOATING', re.compile('(?i)GFLOATING')),
        ('HFLOATING', re.compile('(?i)HFLOATING')),
        ('LONG_FLOAT', re.compile('(?i)LONG[ \t]+FLOAT')),
        ('LONGWORD_INTEGER', re.compile('(?i)LONGWORD[ \t]+INTEGER')),
        ('QUADWORD_INTEGER', re.compile('(?i)QUADWORD[ \t]+INTEGER')),
        ('SFLOATING', re.compile('(?i)SFLOATING')),
        ('SHORT_FLOAT', re.compile('(?i)SHORT[ \t]+FLOAT')),
        ('TFLOATING', re.compile('(?i)TFLOATING')),
        ('UNSIGNED_BYTE', re.compile('(?i)UNSIGNED[ \t]+BYTE')),
        ('UNSIGNED_LONGWORD', re.compile('(?i)UNSIGNED[ \t]+LONGWORD')),
        ('UNSIGNED_WORD', re.compile('(?i)UNSIGNED[ \t]+WORD')),
        ('WORD_INTEGER', re.compile('(?i)WORD[ \t]+INTEGER')),
        ('XFLOATING', re.compile('(?i)XFLOATING')),
        ('CHARACTER', re.compile('(?i)CHARACTER')),
        ('VARYING', re.compile('(?i)VARYING')),
        ('NULL_TERMINATED', re.compile('(?i)NULL[ \t]+TERMINATED')),
        ('INTEGER', re.compile('(?i)INTEGER')),
        ('DECIMAL', re.compile('(?i)DECIMAL')),
        ('FLOAT', re.compile('(?i)FLOAT')),
        ('PACKED', re.compile('(?i)PACKED')),
        ('ADT', re.compile('(?i)ADT')),
        ('DATE', re.compile('(?i)DATE')),
        ('TIME', re.compile('(?i)TIME')),
        ('DATETIME', re.compile('(?i)DATETIME')),
        ('CURRENT', re.compile('(?i)CURRENT')),
        ('INTEGER_LITERAL', re.compile('\\d+')),
        ('DECIMAL_LITERAL', re.compile('\\d*\\.\\d+(E\\d+)?')),
        ('DATETIME_LITERAL', re.compile('\\d+')),
        ('TEXT_LITERAL', re.compile('"[^"\r\n]|"""|\'[^\'\r\n]|\'\'\'')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'[ \r\t\n]+':None,},str,*args,**kw)

class IFDL(runtime.Parser):
    Context = runtime.Context
    def form_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'form_declaration', [])
        FORM = self._scan('FORM', context=_context)
        NAME = self._scan('NAME', context=_context)
        push(df_classes.Form(NAME))
        while self._peek('FORM_RECORD', 'FORM_DATA', 'END_FORM', 'LAYOUT', context=_context) == 'FORM_DATA':
            form_data_declaration = self.form_data_declaration(_context)
        while self._peek('END_FORM', 'LAYOUT', 'FORM_RECORD', context=_context) == 'FORM_RECORD':
            form_record_declaration = self.form_record_declaration(_context)
        while self._peek('END_FORM', 'LAYOUT', context=_context) == 'LAYOUT':
            layout_declaration = self.layout_declaration(_context)
        END_FORM = self._scan('END_FORM', context=_context)
        pop()

    def form_data_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'form_data_declaration', [])
        FORM_DATA = self._scan('FORM_DATA', context=_context)
        push(df_classes.Form_data())
        if self._peek('TRACKED', 'UNTRACKED', 'END_DATA', 'NAME', context=_context) in ['TRACKED', 'UNTRACKED']:
            track_clause_1 = self.track_clause_1(_context)
        while self._peek('END_DATA', 'NAME', context=_context) == 'NAME':
            form_data_item_declaration = self.form_data_item_declaration(_context)
        END_DATA = self._scan('END_DATA', context=_context)
        pop()

    def track_clause_1(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'track_clause_1', [])
        _token = self._peek('TRACKED', 'UNTRACKED', context=_context)
        if _token == 'TRACKED':
            TRACKED = self._scan('TRACKED', context=_context)
            push(df_classes.Tracked()); pop()
        else: # == 'UNTRACKED'
            UNTRACKED = self._scan('UNTRACKED', context=_context)
            push(df_classes.Untracked()); pop()

    def form_data_item_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'form_data_item_declaration', [])
        NAME = self._scan('NAME', context=_context)
        _token = self._peek('CHARACTER', 'INTEGER', 'DECIMAL', 'FLOAT', 'BYTE_INTEGER', 'DFLOATING', 'FFLOATING', 'GFLOATING', 'HFLOATING', 'LONG_FLOAT', 'LONGWORD_INTEGER', 'QUADWORD_INTEGER', 'SFLOATING', 'SHORT_FLOAT', 'TFLOATING', 'UNSIGNED_BYTE', 'UNSIGNED_LONGWORD', 'UNSIGNED_WORD', 'WORD_INTEGER', 'XFLOATING', 'ADT', 'DATE', 'TIME', 'DATETIME', context=_context)
        if _token in ['CHARACTER', 'INTEGER', 'DECIMAL', 'FLOAT']:
            text_data_clause = self.text_data_clause(_context)
        elif _token not in ['ADT', 'DATE', 'TIME', 'DATETIME']:
            atomic_clause = self.atomic_clause(_context)
        else: # in ['ADT', 'DATE', 'TIME', 'DATETIME']
            datetime_data_clause = self.datetime_data_clause(_context)
        if self._peek('VALUE', 'END_DATA', 'NAME', context=_context) == 'VALUE':
            VALUE = self._scan('VALUE', context=_context)
            literal = self.literal(_context)

    def literal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'literal', [])
        _token = self._peek('INTEGER_LITERAL', 'DECIMAL_LITERAL', 'DATETIME_LITERAL', 'TEXT_LITERAL', context=_context)
        if _token == 'INTEGER_LITERAL':
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
        elif _token == 'DECIMAL_LITERAL':
            DECIMAL_LITERAL = self._scan('DECIMAL_LITERAL', context=_context)
        elif _token == 'DATETIME_LITERAL':
            DATETIME_LITERAL = self._scan('DATETIME_LITERAL', context=_context)
        else: # == 'TEXT_LITERAL'
            TEXT_LITERAL = self._scan('TEXT_LITERAL', context=_context)

    def text_data_clause(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'text_data_clause', [])
        _token = self._peek('CHARACTER', 'INTEGER', 'DECIMAL', 'FLOAT', context=_context)
        if _token == 'CHARACTER':
            CHARACTER = self._scan('CHARACTER', context=_context)
            self._scan('"\\("', context=_context)
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
            self._scan('"\\)"', context=_context)
            if self._peek('NULL_TERMINATED', 'VARYING', 'VALUE', 'END_DATA', 'NAME', context=_context) in ['NULL_TERMINATED', 'VARYING']:
                _token = self._peek('NULL_TERMINATED', 'VARYING', context=_context)
                if _token == 'NULL_TERMINATED':
                    NULL_TERMINATED = self._scan('NULL_TERMINATED', context=_context)
                else: # == 'VARYING'
                    VARYING = self._scan('VARYING', context=_context)
            push(df_classes.Character_data(INTEGER_LITERAL, "VARYING" in locals(), "NULL_TERMINATED" in locals())); pop()
        elif _token == 'INTEGER':
            INTEGER = self._scan('INTEGER', context=_context)
            push(df_classes.Integer()); pop()
            self._scan('"\\("', context=_context)
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
            push(df_classes.Integer_literal(INTEGER_LITERAL)); pop()
            self._scan('"\\)"', context=_context)
            if self._peek('PACKED', 'VALUE', 'END_DATA', 'NAME', context=_context) == 'PACKED':
                PACKED = self._scan('PACKED', context=_context)
                push(df_classes.Packed()); pop()
        elif _token == 'DECIMAL':
            DECIMAL = self._scan('DECIMAL', context=_context)
            push(df_classes.Decimal()); pop()
            self._scan('"\\("', context=_context)
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
            push(df_classes.Integer_literal(INTEGER_LITERAL)); pop()
            self._scan('","', context=_context)
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
            push(df_classes.Integer_literal(INTEGER_LITERAL)); pop()
            self._scan('"\\)"', context=_context)
            if self._peek('PACKED', 'VALUE', 'END_DATA', 'NAME', context=_context) == 'PACKED':
                PACKED = self._scan('PACKED', context=_context)
                push(df_classes.Packed()); pop()
        else: # == 'FLOAT'
            FLOAT = self._scan('FLOAT', context=_context)
            push(df_classes.Float()); pop()
            self._scan('"\\("', context=_context)
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
            push(df_classes.Integer_literal(INTEGER_LITERAL)); pop()
            if self._peek('","', '"\\)"', context=_context) == '","':
                self._scan('","', context=_context)
                INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
                push(df_classes.Integer_literal(INTEGER_LITERAL)); pop()
            self._scan('"\\)"', context=_context)

    def atomic_clause(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'atomic_clause', [])
        _token = self._peek('BYTE_INTEGER', 'DFLOATING', 'FFLOATING', 'GFLOATING', 'HFLOATING', 'LONG_FLOAT', 'LONGWORD_INTEGER', 'QUADWORD_INTEGER', 'SFLOATING', 'SHORT_FLOAT', 'TFLOATING', 'UNSIGNED_BYTE', 'UNSIGNED_LONGWORD', 'UNSIGNED_WORD', 'WORD_INTEGER', 'XFLOATING', context=_context)
        if _token == 'BYTE_INTEGER':
            BYTE_INTEGER = self._scan('BYTE_INTEGER', context=_context)
            push(df_classes.Byte_integer()); pop()
        elif _token == 'DFLOATING':
            DFLOATING = self._scan('DFLOATING', context=_context)
            push(df_classes.Dfloating()); pop()
        elif _token == 'FFLOATING':
            FFLOATING = self._scan('FFLOATING', context=_context)
            push(df_classes.Ffloating()); pop()
        elif _token == 'GFLOATING':
            GFLOATING = self._scan('GFLOATING', context=_context)
            push(df_classes.Gfloating()); pop()
        elif _token == 'HFLOATING':
            HFLOATING = self._scan('HFLOATING', context=_context)
            push(df_classes.HFloating()); pop()
        elif _token == 'LONG_FLOAT':
            LONG_FLOAT = self._scan('LONG_FLOAT', context=_context)
            push(df_classes.Long_float()); pop()
        elif _token == 'LONGWORD_INTEGER':
            LONGWORD_INTEGER = self._scan('LONGWORD_INTEGER', context=_context)
            push(df_classes.Longword_integer()); pop()
        elif _token == 'QUADWORD_INTEGER':
            QUADWORD_INTEGER = self._scan('QUADWORD_INTEGER', context=_context)
            push(df_classes.Quadword_integer()); pop()
        elif _token == 'SFLOATING':
            SFLOATING = self._scan('SFLOATING', context=_context)
            push(df_classes.Sfloating()); pop()
        elif _token == 'SHORT_FLOAT':
            SHORT_FLOAT = self._scan('SHORT_FLOAT', context=_context)
            push(df_classes.Short_float()); pop()
        elif _token == 'TFLOATING':
            TFLOATING = self._scan('TFLOATING', context=_context)
            push(df_classes.Tfloating()); pop()
        elif _token == 'UNSIGNED_BYTE':
            UNSIGNED_BYTE = self._scan('UNSIGNED_BYTE', context=_context)
            push(df_classes.Unsigned_byte()); pop()
        elif _token == 'UNSIGNED_LONGWORD':
            UNSIGNED_LONGWORD = self._scan('UNSIGNED_LONGWORD', context=_context)
            push(df_classes.Unsigned_longword()); pop()
        elif _token == 'UNSIGNED_WORD':
            UNSIGNED_WORD = self._scan('UNSIGNED_WORD', context=_context)
            push(df_classes.Unsigned_word()); pop()
        elif _token == 'WORD_INTEGER':
            WORD_INTEGER = self._scan('WORD_INTEGER', context=_context)
            push(df_classes.Word_integer()); pop()
        else: # == 'XFLOATING'
            XFLOATING = self._scan('XFLOATING', context=_context)
            push(df_classes.Xfloating()); pop()

    def datetime_data_clause(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'datetime_data_clause', [])
        _token = self._peek('ADT', 'DATE', 'TIME', 'DATETIME', context=_context)
        if _token == 'ADT':
            ADT = self._scan('ADT', context=_context)
            push(df_classes.Adt()); pop()
            if self._peek('CURRENT', 'VALUE', 'END_DATA', 'NAME', context=_context) == 'CURRENT':
                CURRENT = self._scan('CURRENT', context=_context)
                push(df_classes.Current()); pop()
        elif _token == 'DATE':
            DATE = self._scan('DATE', context=_context)
            push(df_classes.Date()); pop()
            if self._peek('CURRENT', 'VALUE', 'END_DATA', 'NAME', context=_context) == 'CURRENT':
                CURRENT = self._scan('CURRENT', context=_context)
                push(df_classes.Current()); pop()
        elif _token == 'TIME':
            TIME = self._scan('TIME', context=_context)
            push(df_classes.Time()); pop()
            if self._peek('CURRENT', 'VALUE', 'END_DATA', 'NAME', context=_context) == 'CURRENT':
                CURRENT = self._scan('CURRENT', context=_context)
                push(df_classes.Current()); pop()
        else: # == 'DATETIME'
            DATETIME = self._scan('DATETIME', context=_context)
            self._scan('"\\("', context=_context)
            INTEGER_LITERAL = self._scan('INTEGER_LITERAL', context=_context)
            self._scan('"\\)"', context=_context)
            push(df_classes.Datetime(INTEGER_LITERAL)); pop()

    def form_record_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'form_record_declaration', [])
        FORM_RECORD = self._scan('FORM_RECORD', context=_context)
        NAME = self._scan('NAME', context=_context)
        push(df_classes.Form_record(NAME))
        END_RECORD = self._scan('END_RECORD', context=_context)
        pop()

    def layout_declaration(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'layout_declaration', [])
        LAYOUT = self._scan('LAYOUT', context=_context)
        NAME = self._scan('NAME', context=_context)
        push(df_classes.Layout(NAME))
        END_LAYOUT = self._scan('END_LAYOUT', context=_context)
        pop()


def parse(rule, text):
    P = IFDL(IFDLScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
